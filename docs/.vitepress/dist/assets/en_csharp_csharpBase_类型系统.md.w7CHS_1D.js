import{_ as i,o as a,c as e,ak as t,al as l,am as h,an as n}from"./chunks/framework.CLmQc1tu.js";const y=JSON.parse('{"title":"C# 类型系统","description":"","frontmatter":{},"headers":[],"relativePath":"en/csharp/csharpBase/类型系统.md","filePath":"en/csharp/csharpBase/类型系统.md"}'),p={name:"en/csharp/csharpBase/类型系统.md"};function d(r,s,k,c,o,g){return a(),e("div",null,[...s[0]||(s[0]=[t(`<h1 id="c-类型系统" tabindex="-1">C# 类型系统 <a class="header-anchor" href="#c-类型系统" aria-label="Permalink to “C# 类型系统”">​</a></h1><h2 id="c-类型概述" tabindex="-1">C# 类型概述 <a class="header-anchor" href="#c-类型概述" aria-label="Permalink to “C# 类型概述”">​</a></h2><p>C# 作为一门静态强类型语言，每个变量和常量都应该有各自的类型，每个求值的表达式也有类型。C# 主要采用的是规范类型系统。规范类型系统使用名称来标识每一种类型，例如：<code>struct</code>、<code>class</code> 和 <code>interface</code>，甚至是 <code>record</code> 类型，都是通过其名称来标识的。</p><h2 id="c-的类型类别" tabindex="-1">C# 的类型类别 <a class="header-anchor" href="#c-的类型类别" aria-label="Permalink to “C# 的类型类别”">​</a></h2><p>C# 的类型被分为了两大类：</p><ol><li>值类型（Value Type）</li><li>引用类型（Reference Type）</li></ol><h2 id="值类型" tabindex="-1">值类型 <a class="header-anchor" href="#值类型" aria-label="Permalink to “值类型”">​</a></h2><h3 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to “概述”">​</a></h3><p>值类型直接存储变量的实例，通常分配在栈上。继承自 <code>System.ValueType</code>（而 <code>System.ValueType</code> 又继承自 <code>System.Object</code>）</p><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to “特点”">​</a></h3><p>由于值类型是直接在栈上存储变量的实例，所以在赋值、方法传参和作为方法的返回值时默认是采用的实例拷贝的方式。即把整个变量的实例复制给被赋值的变量。</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-42" id="tab-43" checked><label data-title="C#" for="tab-43">C#</label></div><div class="blocks"><div class="language-cs active"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变量a将实例拷贝进了变量b里</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变量b的实例来自变量a的拷贝，所以修改变量b的值并不会影响变量a的值</span></span></code></pre></div></div></div><p><strong>内存结构图：</strong></p><img src="`+l+`" width="50%"><div class="tip custom-block github-alert"><p class="custom-block-title">提示</p><p>值类型在声明时，也不一定是存储在栈上的，值类型实际的存储位置是根据当前所属的对象的类型决定的。</p><p>如果是声明局部变量，那么这个变量就一定是存储在栈上的。</p><p>如果是在一个引用类型中声明的值类型的变量，那么这个值类型的变量就是存储在堆中的。</p></div><h2 id="引用类型" tabindex="-1">引用类型 <a class="header-anchor" href="#引用类型" aria-label="Permalink to “引用类型”">​</a></h2><h3 id="概述-1" tabindex="-1">概述 <a class="header-anchor" href="#概述-1" aria-label="Permalink to “概述”">​</a></h3><p>定义为 <code>class</code> 、 <code>record class</code> 、 <code>record</code> 、 <code>delegate</code> 、数组或 <code>interface</code> 的类型属于 <code>reference type</code> 。</p><p>当声明一个 <code>reference type</code> 类型的变量时，该变量将包含值 <code>null</code> ，直到为其分配该类型的实例或使用 <code>new</code> 运算符创建一个实例。以下示例演示了类的创建和赋值：</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-72" id="tab-73" checked><label data-title="C#" for="tab-73">C#</label></div><div class="blocks"><div class="language-cs active"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1;</span></span></code></pre></div></div></div><h3 id="特点-1" tabindex="-1">特点 <a class="header-anchor" href="#特点-1" aria-label="Permalink to “特点”">​</a></h3><p>引用类型之所以叫引用类型，就是因为它在栈上并不直接存储实例，而是将实例存储在了堆中，栈中存储了指向堆中实例的引用。在赋值时，引用类型只会复制引用至被赋值对象，所以这就造成了引用类型与值类型不同的赋值行为。</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-81" id="tab-82" checked><label data-title="C#" for="tab-82">C#</label></div><div class="blocks"><div class="language-cs active"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由于Person类是引用类型，所以p2只是复制了p1的引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p2.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;John&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &quot;John&quot;</span></span></code></pre></div></div></div><p>两个变量的引用相同，那么它们就指向了堆中同一块内存区域，这时候修改任意一方都会影响另一方。</p><p><strong>内存结构图：</strong></p><img src="`+h+'" width="70%"><div class="tip custom-block github-alert"><p class="custom-block-title">提示</p><p>引用类型的引用存储也不一定是在栈上，它的存储位置取决于是声明局部变量，还是在引用类型中声明。</p><p>如果是声明局部变量，那么引用就是存储在栈中。</p><p>如果是在一个引用类型，例如某个类中声明的类字段，那么这个引用类型的字段就是将引用存储在堆中，实例同样存储在堆中。</p></div><h2 id="特殊存储时的内存结构图" tabindex="-1">特殊存储时的内存结构图 <a class="header-anchor" href="#特殊存储时的内存结构图" aria-label="Permalink to “特殊存储时的内存结构图”">​</a></h2><h3 id="值类型声明在引用类型中" tabindex="-1">值类型声明在引用类型中 <a class="header-anchor" href="#值类型声明在引用类型中" aria-label="Permalink to “值类型声明在引用类型中”">​</a></h3><p><strong>内存结构图：</strong></p><p>可以很明显的看到，值类型在引用类型中声明时，它的实例与值都是存储在了堆中。 <img src="'+n+'" width="70%"></p><p>其余的特殊情况如上面的提示所述，这里就不多赘述了。</p>',32)])])}const E=i(p,[["render",d]]);export{y as __pageData,E as default};
